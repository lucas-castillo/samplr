---
title: "Simulations of the Autocorrelated Bayesian Sampler"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulations-of-the-Autocorrelated-Bayesian-Sampler}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides a brief introduction of the Autocorrelated Bayesian Sampler (ABS, Zhu et al., 2023) and the `R` scripts for running simulations of ABS using `samplr` package.

ABS is a sequential sampling model that assumes individuals draw autocorrelated samples from their memory of hypotheses based on their posterior beliefs. These samples are subsequently integrated to perform various tasks: ABS is capable of generating estimates, confidence intervals, and response times for estimation tasks, as well as choices, confidence judgments, and response times for 2AFC. In this vignette, we will outline the process of simulating both types of tasks using ABS.

## Estimation task

Estimation tasks involve participants providing estimates, such as the number of stimuli (e.g., dots) on a screen or offering confidence intervals of that counts at a specified level.

In this vignette, we will begin by generating several random numbers to represent the stimuli counts. We will assume the estimation task consists of 10 trials, wherein participants are tasked with estimating the number of dots displayed on the screen in each trial.

```{r setup}
require(samplr)

set.seed(2024)
stim <- sample(20:25, 10, replace=TRUE)
```

ABS employs [R6][R6::R6Class] object-oriented programming (OOP) system. Thus we need to construct a new object before running simulations. In the initialising step, we need to provide the values of five parameters:

-  the proposal width of the MC3 sampler, `width`;
-  the number of chains of the MC3 sampler, `n_chains`;
-  the lower bound of the non-decision time, `nd_time`;
-  the variability of the non-decision time, `s_nd_time`;
-  the lambda of the Erlang distribution for the response time, `lambda`.

```{r}
abs_model <- Zhu23ABS$new(width=1, n_chains = 3, nd_time = 0.3, s_nd_time = 0.2, lambda = 10)
```

As we are going to use ABS to simulate a estimation task, we need to call the method `estimate` with further two arguments:

-  the absolute stopping rule, `n_sample`;
-  the stimuli of the estimate task, `trial_stim`;

```{r, results = FALSE}
abs_model$estimate(n_sample = 5, trial_stim = stim)
```

The results of the `estimate` method save in the field `ss_samples`, which represents the samples of a "single-stimulus" task. Users can get access to the results by `abs_model$ss_samples`. It is important to note that ABS assumes the response time for each trial follows an Erlang distribution, with the shape parameter equal to the length of the samples which is determined by `n_sample`. The response time value provided in the table is a random number drawn from the Erlang distribution.

```{r}
knitr::kable(abs_model$ss_samples)
```

In addition to performing point estimation, ABS can also simulate confidence interval estimation by the `confidence_interval` method.

```{r}
abs_model$confidence_interval(0.5)
```

The following table shows the interval estimation on the level of 0.5. `conf_interval_l` and `conf_interval_u` represent the lower and the upper bounds.

```{r}
knitr::kable(abs_model$ss_samples)
```

An advantage of R6 is that it allows method chaining, which means that we can simulate the point and confidence interval estimation in one line of code. However, it is worth noticing that before rerunning the simulation, users should either create a new object or reset the `ss_samples` using the `ss_reset` method.

```{r}
abs_model$ss_reset()
abs_model$estimate(n_sample = 5, trial_stim = stim)$confidence_interval(0.5)
knitr::kable(abs_model$ss_samples)
```

## Two-alternative force choice task (2AFC)

2AFC is a cognitive task that asks participants to make judgments between two alternatives. For instance, in the random dot motion task (RDM), participants are presented with a screen where most dots move coherently in either the left or right direction, and they're asked to perceive the correct direction.

ABS is able to describe and simulate this cognitive process. Similarly, we will begin by randomly generating 10 directions from the set `c('left', 'right')` to represent the stimuli in the RDM task.

```{r}
trial_stim <- factor(sample(c('left', 'right'), 10, TRUE))
```

In 2AFC, ABS employs a sampling process and converts the samples into "evidence" supporting either the left or right responses. Specifically, if the sample falls below the decision boundary, it supports the first level in `trial_stim`, which in our example is "left"; otherwise, the sample will support the second level, which is "right".

To simulate the 2AFC of ABS, we need to initialize a new ABS model and then use the `two_alt_force_choice` method. In addition to specifying the parameters `width`, `n_chains`, `nd_time`, `s_nd_time`, and `lambda` during initialization, we should also provide values for the following arguments in the `two_alt_force_choice` method:

- the relative stopping rule, `delta`;
- the decision boundary, `dec_bdry`;
- the discriminability, `discrim`;
- the stimuli, `trial_stim`;
- the prior on responses, `prior_on_resp`.

There are another four arguments with default settings that can be modified:

- the prior on responses, `prior_on_resp`, which determines the prior preference for the stimuli. The default setting is `c(1, 1)`, representing an unbiased prior `Beta(1, 1)`. Users can modify this to reflect different prior preferences.
- the starting point, `start_point`, which indicates the starting points of the MC3 sampler. By default, it's set to `NA`, meaning the starting point of each trial is the last sample of the previous trial. Alternatively, users can specify starting points for each trial, ensuring that the length of starting points matches the length of `trial_stim`.
- the stimuli dependency, `stim_depend`, which controls whether the prior on responses changes based on the previous stimulus. The default setting is `TRUE`, which adjusts the prior by adding 1 according to the previous stimulus.
- the maximum length of the MC3 sampler, `max_iterations`, which determines the maximum length of the MC3 sampler. The sampler will stop when the length of the samples exceeds this value, even if the samples have not met the relative stop rule. The default setting is 1000, suitable for most cases, but users can adjust it based on the discriminability and the relative stopping rule.

To demonstrate the usage of these arguments, we'll run the simulation twice: once with the default settings and again with some of the settings modified.

```{r, results=FALSE}
abs_model2 <- Zhu23ABS$new(width=1, n_chains = 3, nd_time = 0.3, s_nd_time = 0.2, lambda = 10)
abs_model2$two_alt_force_choice(delta = 3, dec_bdry = 0, discrim = 1, trial_stim = trial_stim)
```

The table below presents the simulation results, including the simulated response, response time, and confidence. It is important to note that in the simulation of 2AFC, the length of the sample sequences may vary due to ABS utilizing a relative stopping rule. To illustrate its mechanism, let us examine the sequences in the first two trials as an example.

```{r}
knitr::kable(abs_model2$ta_samples)
```

The prior on responses, set to `c(1, 1)`, corresponds to an unbiased Beta distribution `Beta(1, 1)`. Let us consider the first trial: the initial sample, -0.4116222, falls below the decision boundary of 0, supporting "left". Consequently, the posterior on responses shifts to `Beta(2, 1)`. With a relative difference of 1 between the amounts of evidence supporting both stimuli, which is lower than the relative stopping rule, the sampling process continues. Subsequent samples are analysed similarly: the posterior adjusts according to the samples until the relative difference meets the stopping rule. In this case, the last sample supporting "right" results in a posterior of `Beta(3, 6)`, satisfying the stopping rule and prompting ABS to return a "right" response.

With the `stim_depend=TRUE` argument, the prior on responses for the second trial depends on the stimulus of the first trial. Given the stimulus "right" in the first trial, the prior on responses for the second trial is `Beta(1, 2)`. Since no starting points are provided, ABS begins from 1.2250489, the last sample of the first trial, but this sample is excluded from the calculation of the posterior on responses. The process then proceeds similarly to the first trial: samples supporting "right" adjust the posterior until the relative difference meets the stopping rule. In this instance, after two samples supporting "right", the posterior reaches `Beta(1, 4)`, satisfying the stopping rule and resulting in a "right" response.

In the upcoming simulations, we'll run the simulation again with two arguments changed: `start_point` and `stim_depend`. To proceed, let us generate some starting points for the simulation.

```{r}
start_point <- runif(length(trial_stim), -3, 3)
print(start_point)
```

Next, we will put these starting points into the ABS model and rerun the simulation. It is worth noting that in this simulation, the starting point of each trial precisely matches what we provided, and all starting points are included in the calculation of the posterior of responses. Additionally, it is important to observe that the prior on responses resets to `Beta(1, 1)` at the start of every trial.

```{r}
tafc_sim_new <- abs_model2$two_alt_force_choice(delta = 3, dec_bdry = 0, discrim = 1, trial_stim = trial_stim, start_point = start_point, stim_depend = FALSE)
knitr::kable(tafc_sim_new)
```


# References

- Zhu, J.-Q., Sundh, J., Spicer, J., Chater, N., & Sanborn, A. N. (2023). The Autocorrelated Bayesian Sampler: A rational process for probability judgments, estimates, confidence intervals, choices, confidence judgments, and response times. _Psychological Review_. https://doi.org/10.1037/rev0000427
