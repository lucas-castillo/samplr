distr_params = params,
discreteValues = FALSE,
isMix = TRUE,
weights = weights
)
x <- matrix[[1]][1:2**12,1]
y <- matrix[[1]][1:2**12,2]
plot(x,y)
matrix
matrix[[1]]
M <- as.data.frame(matrix[[1]])
M
M <- as.data.frame(matrix[[1]][1:2**12,])
M
M$time <- 1:4096
M
??gganimate::gganimate
ggplot(M, aes(x = V1, y = V2)) + geom_point()
ggplot(M, aes(x = V1, y = V2)) + geom_point() + transition_states(time, transition_length = 2, state_length = 1)
ggplot(M, aes(x = V1, y = V2)) + geom_point() + transition_states(time, transition_length = 4096, state_length = 1)
ANIM <- ggplot(M, aes(x = V1, y = V2)) + geom_point() + transition_states(time, transition_length = 4096, state_length = 1)
ANIM <- ggplot(M, aes(x = V1, y = V2)) + geom_point() + transition_states(time, transition_length = 4096, state_length = 1)
ANIM
warnings()
plot(M)
ggplot(M, aes(x = V1, y = V2))
ggplot(M, aes(x = V1, y = V2)) + geom_point()
ggplot(M[1:10], aes(x = V1, y = V2)) + geom_point()
ggplot(M[M$time < 10], aes(x = V1, y = V2)) + geom_point()
ggplot(M[M$time < 10, ], aes(x = V1, y = V2)) + geom_point()
ggplot(M[M$time < 100, ], aes(x = V1, y = V2)) + geom_point()
library(samplr)
library(ggplot2)
library(stats)
runif(2)
apply(X)
M <- matrix(0, nrow = 15, ncol = 2)
apply(M, 1, runif(2) * 18 - 9)
rep(1,2)
M <- matrix(1:5)
M <- matrix(1:5)
M
M <- matrix(rep(runif(1) * 18 - 9, 30), nrow=15, ncol = 2)
M
runif(30)
M <- matrix((runif(30) * 18 - 9), nrow=15, ncol = 2)
M
weights <- rep(1/15, length.out = 15)
cumulative_weights <- vector()
for (i in 1:length(weights)){
if (i == 1){
cumulative_weights[i] <- weights[i]
} else {
cumulative_weights[i] <- weights[i] + cumulative_weights[i-1]
}
}
cumulative_weights
cumsum(weights)
cumsum(weights) == cumulative_weights
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[i] <- runif(2)
}
parameters
runif(2)
for (i in 1:15){
parameters[[i]] <- runif(2)
}
parameters
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- runif(2)
}
The probability density function is the weighted sum of each of the density functions
```{r}
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = c(M[i,1], M[i,2]), log = log)
}
return(sum(densities * weights))
}
```
The random function chooses a random distribution from the mixture to draw a sample from (with weighted probabilities)
```{r}
rand_func <- function(x){
randNums <- matrix(ncol = dims, nrow = x)
for (j in 1:x){
randomN <- stats::runif(1)
finish = F
i = 0
while (!finish){
i = i + 1
if (randomN <= cumulative_weights[i]){
dist <- listDistr[[i]]
randNums[j,] <- unlist(unname(dist$rand(1)))
finish = T
}
}
}
return(randNums)
}
```
We can now draw a map of the density
```{r, dpi=150, fig.align="center"}
mapDensity <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
#  is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = c(M[i,1], M[i,2]), log = log)
}
return(sum(densities * weights))
}
weights <- rep(1/15, length.out = 15)
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = c(M[i,1], M[i,2]), log = log)
}
return(sum(densities * weights))
}
mapDensity <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
#  is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- vector()
for (i in 1:length(yyRange)){
density[i] <- pdf(c(xxRange[i],yyRange[i]))
}
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
hills_df <- mapDensity(pd_func, c(-10,-10), 20, 150)
hill_map <- ggplot(hills_df) +
geom_raster(mapping = aes(x = x, y = y, fill = density)) +
scale_fill_viridis_c() +
theme_void()
print(hill_map)
MCMC <- sampler_mcmc_cpp(start = c(0,0), sigma_prop = diag(2), iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC <- sampler_mcmc_cpp(start = c(0,0), sigma_prop = diag(2), iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
names
params
parameters
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2), diag(2))
}
MCMC <- sampler_mcmc_cpp(start = c(0,0), sigma_prop = diag(2), iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(0,0), sigma_prop = diag(2) * 2, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(0,0), sigma_prop = diag(2) * 5, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(5,0), sigma_prop = diag(2) * 5, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(10,0), sigma_prop = diag(2) * 5, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(10,5), sigma_prop = diag(2) * 5, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(5,5), sigma_prop = diag(2) * 5, iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC <- sampler_mcmc_cpp(start = c(5,5), sigma_prop = diag(2), iterations = 2**10, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MCMC[[1]]
MCMC <- sampler_mcmc_cpp(start = c(5,5), sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MC3 <-  sampler_mc3_cpp(start = c(5,5), nChains = 6, delta_T = 4, swap_all = TRUE, sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MC3 <-  sampler_mc3_cpp(start = c(5,5), nChains = 6, delta_T = 4, swap_all = TRUE, sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MC3_df <- data.frame(x = MC3[[1]][1:2**12,1], y = MC3[[1]][1:2**12,2])
MC3_path <- hill_map +
geom_path(MC3_df, mapping = aes(x, y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MC3_df, mapping = aes(x,y), colour = "white", size =.1)
print(MC3_path)
parameters
parameters[[1]]
parameters[[1]][1]
parameters[[1]][[1]]1
parameters[[1]][[1]]
parameters
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[i] <- list(runif(2), diag(2))
}
```{r}
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2), diag(2))
}
parameters
mapDensity <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
# size is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- vector()
for (i in 1:length(yyRange)){
density[i] <- pdf(c(xxRange[i],yyRange[i]))
}
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
hills_df <- mapDensity(pd_func, c(-10,-10), 20, 150)
hills_df <- mapDensity(pd_func, c(-10,-10), 20, 150)
hill_map <- ggplot(hills_df) +
geom_raster(mapping = aes(x = x, y = y, fill = density)) +
scale_fill_viridis_c() +
theme_void()
hill_map
MCMC <- sampler_mcmc_cpp(start = c(5,5), sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
MC3 <-  sampler_mc3_cpp(start = c(5,5), nChains = 6, delta_T = 4, swap_all = TRUE, sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MC3_df <- data.frame(x = MC3[[1]][1:2**12,1], y = MC3[[1]][1:2**12,2])
MC3_path <- hill_map +
geom_path(MC3_df, mapping = aes(x, y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MC3_df, mapping = aes(x,y), colour = "white", size =.1)
print(MC3_path)
library(samplr)
library(ggplot2)
library(stats)
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
library(samplr)
library(ggplot2)
library(stats)
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2), diag(2))
}
# ```
# We'll also require a set of weights (which in this case will all be the same), which we will use in our probability density function, as well as a set of cumulative weights, for our random sampler.
# ```{r}
weights <- rep(1/15, length.out = 15)
# ```
#
# The probability density function is the weighted sum of each of the density functions
# ```{r}
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = parameters[[i]][[1]], sigma = diag(2), log = log)
}
return(sum(densities * weights))
}
pd_func(c(0,1))
pd_func(c(1,1))
pd_func(c(1,4))
#                                 <!--         finish = T -->
#                                   <!--       } -->
#                         <!--     } -->
#                   <!--   } -->
#         <!--   return(randNums) -->
#         <!-- } -->
#   <!-- ``` -->
#
#   We can now draw a map of the density
# ```{r, dpi=150, fig.align="center"}
mapDensity <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
# size is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- vector()
for (i in 1:length(yyRange)){
density[i] <- pdf(c(xxRange[i],yyRange[i]))
}
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
hills_df <- mapDensity(pd_func, c(-10,-10), 20, 150)
# ```
# An MCMC sampler may not be able to explore the whole of the space, as it is unable to make long jumps
# ```{r ,dpi=150, fig.align="center"}
MCMC <- sampler_mcmc_cpp(start = c(5,5), sigma_prop = diag(2), iterations = 2**12, distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
hill_map <- ggplot(hills_df) +
geom_raster(mapping = aes(x = x, y = y, fill = density)) +
scale_fill_viridis_c() +
theme_void()
print(hill_map)
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
# ```
# We'll also require a set of weights (which in this case will all be the same), which we will use in our probability density function, as well as a set of cumulative weights, for our random sampler.
# ```{r}
weights <- rep(1/15, length.out = 15)
# ```
#
# The probability density function is the weighted sum of each of the density functions
# ```{r}
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = parameters[[i]][[1]], sigma = diag(2), log = log)
}
return(sum(densities * weights))
}
#                                 <!--         finish = T -->
#                                   <!--       } -->
#                         <!--     } -->
#                   <!--   } -->
#         <!--   return(randNums) -->
#         <!-- } -->
#   <!-- ``` -->
#
#   We can now draw a map of the density
# ```{r, dpi=150, fig.align="center"}
mapDensity <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
# size is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- vector()
for (i in 1:length(yyRange)){
density[i] <- pdf(c(xxRange[i],yyRange[i]))
}
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
hills_df <- mapDensity(pd_func, c(-10,-10), 20, 150)
hill_map <- ggplot(hills_df) +
geom_raster(mapping = aes(x = x, y = y, fill = density)) +
scale_fill_viridis_c() +
theme_void()
print(hill_map)
# ```
# An MCMC sampler may not be able to explore the whole of the space, as it is unable to make long jumps
# ```{r ,dpi=150, fig.align="center"}
MCMC <- sampler_mcmc_cpp(
start = c(5,5), sigma_prop = diag(2), iterations = 2**12,
distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
# ```
# An MCMC sampler may not be able to explore the whole of the space, as it is unable to make long jumps
# ```{r ,dpi=150, fig.align="center"}
MCMC <- sampler_mcmc_cpp(
start = c(5,5), sigma_prop = diag(2) / 8, iterations = 2**12,
distr_name = names, distr_params = parameters, discreteValues = FALSE, isMix = TRUE, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
MCMC_path <- hill_map +
geom_path(MCMC_df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MCMC_df, mapping = aes(x,y), colour = "white",size =.1)
print(MCMC_path)
# ```
# An MC3 sampler, on the other hand, runs hotter chains under the hood with which it switches stochastically, which allows it to visit far-off regions and thus explore the whole hypothesis space
# ```{r, dpi=150, fig.align="center"}
MC3 <-  sampler_mc3_cpp(
start = c(5,5), nChains = 6, delta_T = 4, swap_all = TRUE,
sigma_prop = diag(2) / 8, iterations = 2**12,
distr_name = names, distr_params = parameters,
discreteValues = FALSE, isMix = TRUE, weights = weights
)
MC3_df <- data.frame(x = MC3[[1]][1:2**12,1], y = MC3[[1]][1:2**12,2])
MC3_path <- hill_map +
geom_path(MC3_df, mapping = aes(x, y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MC3_df, mapping = aes(x,y), colour = "white", size =.1)
print(MC3_path)
# ```
# An MC3 sampler, on the other hand, runs hotter chains under the hood with which it switches stochastically, which allows it to visit far-off regions and thus explore the whole hypothesis space
# ```{r, dpi=150, fig.align="center"}
MC3 <-  sampler_mc3_cpp(
start = c(5,5), nChains = 6, delta_T = 4, swap_all = FALSE,
sigma_prop = diag(2) / 8, iterations = 2**12,
distr_name = names, distr_params = parameters,
discreteValues = FALSE, isMix = TRUE, weights = weights
)
MC3_df <- data.frame(x = MC3[[1]][1:2**12,1], y = MC3[[1]][1:2**12,2])
MC3_path <- hill_map +
geom_path(MC3_df, mapping = aes(x, y), colour = "red", linetype = "dashed", size = .3) +
geom_point(MC3_df, mapping = aes(x,y), colour = "white", size =.1)
print(MC3_path)
devtools::build_vignettes()
usethis::use_vignette("mixture-distributions")
library(samplr)
names <- c("mvnorm", "mvnorm")
params <- list(
list( # MV NORM 1
c(-2,-2), diag(2)
),
list( # MV NORM 2
c(2,2), diag(2)
)
)
weights <- c(.5, .5)
checkDistrInfo(names, params, c(0,1))
checkDistrInfo(names, params, c(0,1))
names <- c("mv321norm", "mvnorm")
params <- list(
list( # MV NORM 1
c(-2,-2), diag(2)
),
list( # MV NORM 2
c(2,2), diag(2)
)
)
weights <- c(.5, .5)
checkDistrInfo(names, params, c(0,1))
library(samplr)
library(samplr)
names <- c("mvnor1321m", "mvnorm")
params <- list(
list( # MV NORM 1
c(-2,-2), diag(2)
),
list( # MV NORM 2
c(2,2), diag(2)
)
)
weights <- c(.5, .5)
checkDistrInfo(names, params, c(0,1))
