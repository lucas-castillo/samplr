X <- sampler_mc3(n,p,s, sigma_prop = diag(2) * 10)
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mc3(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mc3(n,p,s, sigma_prop = diag(2))
chain <- X[[1]][,,1]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2) * 2 ))
n <- rep("mvnorm", 2)
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2) * 2 ))
s <- c(0,1)
X <- sampler_mc3(n,p,s, sigma_prop = diag(2))
chain <- X[[1]][,,1]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2) * 10 ))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
library(samplr)
n <- rep("mvnorm", 2)
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2) * 10 ))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
sampler_mcmc<- function(distr_name, distr_params, start, sigma_prop = NULL, iterations = 1024L, weights = NULL){
distrInfo = checkGivenInfo(distr_name, distr_params, start, weights, "mcmc", sigma_prop)
isDiscrete = distrInfo[[1]]
isMix = distrInfo[[2]]
print(paste("Is mix = ", isMix))
weights = distrInfo[[3]]
sigma_prop = distrInfo[[4]]
return (sampler_mcmc_cpp(start, sigma_prop, iterations, distr_name, distr_params, discreteValues = isDiscrete, isMix = isMix, weights = 1))
}
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
library(samplr)
n <- rep("mvnorm", 2)
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2) * 10 ))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
library(samplr)
n <- rep("mvnorm", 2)
p <- list(list(c(-2,-2), diag(2) * 2 ), list(c(2,2), diag(2)))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
chain
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
p <- list(list(c(-2,-2), diag(2)), list(c(2,2), diag(2)))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
n <- rep("mvnorm", 2)
p <- list(list(c(-2,-2), diag(2)), list(c(2,2), diag(2)))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
n <- rep("mvnorm", 3)
p <- list(list(c(-2,-2), diag(2)), list(c(2,2), diag(2)), list(c(2,-2), diag(2) / 5))
s <- c(0,1)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
n <- rep("mvnorm", 3)
p <- list(list(c(-2,-2), diag(2)), list(c(2,2), diag(2)), list(c(2,-2), diag(2) / 5))
s <- c(-2,-2)
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2) / 8)
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mc3(n,p,s, sigma_prop = diag(2) / 8)
chain <- X[[1]][,,1]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mc3(n,p,s, sigma_prop = diag(2) / 8)
chain <- X[[1]][,,1]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
X <- sampler_mcmc(n,p,s, sigma_prop = diag(2) / 8)
chain <- X[[1]][,,1]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
chain <- X[[1]]
x <- chain[,1]
y <- chain[,2]
plot(x,y, xlim = c(-4, 4), ylim = c(-4,4))
usethis::use_testthat()
devtools::document()
devtools::document()
devtools::document()
pkgdown::build_site()
.Last.error.trace
samplr::sampler_nuts("norm", c(0,1), 1)
#' @param start Vector. Starting position of the sampler.
#' @param epsilon Size of the leapfrog step
#' @param delta_max Measure of the required accuracy of the simulation. The authors recommend a large value (1000)
#' @param iterations Number of iterations of the sampler.
#' @param weights If using a mixture distribution, the weights given to each constituent distribution. If none given, it defaults to equal weights for all distributions.
#' @export
#'
#' @examples
#' NUTS <- sampler_nuts(distr_name = "norm", distr_params = c(0,1), start = 1)
#'
sampler_nuts <- function(distr_name, distr_params, start, epsilon=.5, delta_max=1000, iterations=1024, weights = NULL) {
distrInfo = checkGivenInfo(distr_name, distr_params, start, weights, "nuts")
isDiscrete = distrInfo[[1]]
isMix = distrInfo[[2]]
weights = distrInfo[[3]]
if (isDiscrete){
stop("NUTS is not supported with discrete distributions")
}
samplerResults <- sampler_nuts_cpp(start, distr_name, distr_params, epsilon, iterations, delta_max, isMix = isMix, weights = weights)
return(
list(
"Samples" = samplerResults[[1]]
)
)
}
samplr::sampler_nuts("norm", c(0,1), 1)
sampler_nuts("norm", c(0,1), 1)
pkgdown::build_site()
.Last.error.trace
samplr::sampler_nuts("norm", c(0,1), 1)
library(samplr)
samplr::sampler_nuts("norm", c(0,1), 1)
devtools::document()
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
library(samplr)
MC3_samples <- sampler_mc3(name, params, start, proposal_variance)
library(samplr)
set.seed(123)
name = "norm"
params = c(0,1)
start = 0
proposal_variance <- 1 / 2
MC3_samples <- sampler_mc3(name, params, start, proposal_variance)
MC3_samples <- sampler_mc3(name, params, start, proposal_variance)
samplerResults
MC3_samples <- sampler_mc3(name, params, start, 6, proposal_variance)
library(samplr)
library(samplr)
devtools::document()
pkgdown::build_articles()
pkgdown::build_site()
library(samplr)
library(ggplot2)
library(stats)
plotPath <- function(df){
path <- hill_map +
geom_path(df, mapping = aes(x,y), colour = "red", linetype = "dashed", size = .3) +
geom_point(df, mapping = aes(x,y), colour = "white",size =.1)
print(path)
}
iterations = 2**10
MCMC <- sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
name
distr_name
names
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
length(names)
iterations = 2**10
MCMC <- sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
weights
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
weights <- rep(1/15, length.out = 15)
iterations = 2**10
MCMC <- sampler_mcmc(distr_name = names, distr_params = parameters, start = c(5,5),
sigma_prop = diag(2) / 8, iterations = iterations, weights = weights)
MCMC_df <- data.frame(x = MCMC[[1]][,1], y = MCMC[[1]][,2])
plotPath(MCMC_df)
weights <- runif(15)
apply(weights, 1, (function(x)(x/sum(weights))))
weights <- runif(15)
apply(weights, 0, (function(x)(x/sum(weights))))
weights <- runif(15)
weights
weights / rep(sum(weights), 15)
sum(weights / rep(sum(weights), 15))
devtools::document()
pkgdown::build_site
pkgdown::build_site()
pkgdown::build_articles()
pkgdown::build_home()
devtools::build_readme()
devtools::build_rmd()
devtools::build_manual()
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
# We'll also require a set of weights (which in this case will all be random). If using equal weights, you will not need to include the weights as a function parameter.
weights <- runif(15)
weights <- weights / rep(sum(weights), 15)n <- rep("mvnorm", 3)
# We'll also require a set of weights (which in this case will all be random). If using equal weights, you will not need to include the weights as a function parameter.
weights <- runif(15)
weights <- weights / rep(sum(weights), 15)n <- rep("mvnorm", 3)
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
# We'll also require a set of weights (which in this case will all be random). If using equal weights, you will not need to include the weights as a function parameter.
weights <- runif(15)
weights <- weights / rep(sum(weights), 15)
names
parameters
weights
hist(weights)
hist(weights, breaks = 15)
plot(weights)
samplr::sampler_hmc(names, parameters, c(0, 1))
samplr::sampler_hmc(names, parameters, c(0, 1))
samplr::sampler_hmc(names, parameters, c(0, 1), weights = weights)
X <- samplr::sampler_hmc(names, parameters, c(0, 1), weights = weights)
plot(x, y)
x <- X$Samples[,1]
y <- X$Samples[,2]
plot(x, y)
for (i in 1:15){
parameters[[i]] <- list(runif(2), diag(2))
}
# We'll also require a set of weights (which in this case will all be random). If using equal weights, you will not need to include the weights as a function parameter.
weights <- runif(15)
weights <- weights / rep(sum(weights), 15)
X <- samplr::sampler_hmc(names, parameters, c(0, 1), weights = weights)
x <- X$Samples[,1]
y <- X$Samples[,2]
plot(x, y)
seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
start = c(1,1)
size = 60
cellsPerRow = 50
seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
size / cellsPerRow
size / (cellsPerRow - 1)
xxRange <- rep(xRange, cellsPerRow)
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
xxRange
library(samplr)
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
Rfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
rep(xRange, cellsPerRow)
}
Cfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
}
Rfunc()
Cfunc()
library(samplr)
Rfunc()
Cfunc()
Rfunc()
Cfunc()
length(Rfunc())
length(Cfunc())
library(samplr)
Rfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
rep(xRange, cellsPerRow)
}
Cfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
}
Rfunc() == Cfunc()
bench::mark(
Cfunc(),
Rfunc()
)
library(samplr)
Rfunc() == Cfunc()
Rfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
rep(xRange, cellsPerRow)
}
Cfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
}
bench::mark(
Cfunc(),
Rfunc()
)
bench::mark(
Cfunc(),
Rfunc(),
check = FALSE
)
Rfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
rep(xRange, cellsPerRow)
}
Cfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
}
bench::mark(
Cfunc(),
Rfunc(),
check = FALSE
)
library(samplr)
Rfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
rep(xRange, cellsPerRow)
}
Cfunc <- function(){
start = c(1,1)
size = 60
cellsPerRow = 50
samplr::plotHills("", list(), c(1,2), start, size, cellsPerRow)
}
bench::mark(
Cfunc(),
Rfunc(),
check = FALSE
)
library(samplr)
set.seed(1)
# Create a matrix with the means of 15 different Gaussians
names <- rep("mvnorm", 15)
parameters <- list()
for (i in 1:15){
parameters[[i]] <- list(runif(2) * 18 - 9, diag(2))
}
weights <- runif(15)
weights <- weights / rep(sum(weights), 15)
pd_func <- function(x, log = FALSE){
densities <- vector()
for (i in 1:length(weights)){
densities[i] <- mvtnorm::dmvnorm(x, mean = parameters[[i]][[1]], sigma = diag(2), log = log)
}
return(sum(densities * weights))
}
mapDensityR <- function(pdf, start, size, cellsPerRow = 50){
# start is a vector <- c(x, y)
# size is a number n so that the map ranges from x, y to x + n, y + n
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- vector()
for (i in 1:length(yyRange)){
density[i] <- pdf(c(xxRange[i],yyRange[i]))
}
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
mapDensityC <- function(names, params, weights, start, size, cellsPerRow = 50){
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- xxRange
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
mapDensityC <- function(names, params, weights, start, size, cellsPerRow = 50){
xRange <- seq(from = start[1], to = start[1] + size, length.out = cellsPerRow)
xxRange <- rep(xRange, cellsPerRow)
yRange <- seq(from = start[2], to = start[2] + size, length.out = cellsPerRow)
for (i in 1:cellsPerRow){
if (i == 1){
yyRange <- rep(yRange[i], cellsPerRow)
} else {
yyRange <- c(yyRange, rep(yRange[i], cellsPerRow))
}
}
density <- samplr::gridDensity(names, params, length(names) > 1, weights, xxRange, yyRange, cellsPerRow)
df <- data.frame(x = xxRange, y = yyRange, density = density)
return(df)
}
bench::mark(
mapDensityR(pdf = pd_func, start = c(-10,-10), size = 20, cellsPerRow = 150),
mapDensityC(names = names, params = parameters, weights = weights, start = c(-10,-10), size = 20, cellsPerRow = 150)
)
bench::mark(
mapDensityR(pdf = pd_func, start = c(-10,-10), size = 20, cellsPerRow = 150),
mapDensityC(names = names, params = parameters, weights = weights, start = c(-10,-10), size = 20, cellsPerRow = 150),
check = FALSE
)
library(samplr)
